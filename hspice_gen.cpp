































#include<iostream>//cout;
#include<fstream>//ofstream;

#define M 3
#define N 3

#define R_wl 5
#define R_bl 5
#define R_min 10
#define R_max 1000

#define V_in_min 0
#define V_in_max 200

#define fn_buff_sz 256
#define gen_ofn(dst,x,y) sprintf(dst,"./hspice/%dx%d_crossbar_gen",x,y)



int main(){
	
	unsigned char ofn[fn_buff_sz]; gen_ofn((char*)ofn,M,N);
	unsigned char data_buff[256];
	std::cout<<"out_fn="<<ofn<<'\n';
	srand(time(NULL));//initialize random seed;
	
	unsigned int R[M][N];
	
	std::ofstream hspice_gen((char*)ofn,std::ios::out);
	if(hspice_gen.is_open()){
		sprintf((char*)data_buff,"*%d by %d crossbar generated by shpice_gen.cpp",M,N);
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n*circuit");
		hspice_gen<<data_buff;
		for(unsigned int i=0;i<M;i++){//generate input voltage sources;
			
			
			sprintf((char*)data_buff,"\nV%d %d 0 %d",i, i+1,10/*rand()%(V_in_max-V_in_min+1)+V_in_min*/);
			hspice_gen<<data_buff;
		}
		for(unsigned int i=0;i<M;i++){//gerating resistances 
			for(unsigned int j=0;j<N;j++){
				if(j!=0){//first collumn (bit line) (j==0) is voltage sources, so it should be generated separately;
					sprintf((char*)data_buff,"\nRwl%d%d %d %d %d",i+1,j+1 , (2*(j)-1)*M+(i+1) , (2*(j+1)-1)*M+(i+1) , R_wl);
					hspice_gen<<data_buff;
				}
				else{
					sprintf((char*)data_buff,"\nRwl%d%d %d %d %d",i+1,j+1 , i+1 , (2*(j+1)-1)*M+(i+1) , R_wl);
					hspice_gen<<data_buff;
				}
				R[i][j]=1000;//rand()%(R_max-R_min+1)+R_min;//memristor resistances;
				sprintf((char*)data_buff,"\nR%d%d %d %d %d",i+1,j+1 , (2*(j+1)-1)*M+(i+1) , (2*(j+1))*M+(i+1), R[i][j]);
				hspice_gen<<data_buff;
				if(i!=M-1){//for last word line its connection node is zero node, hence should be generated separately;
					sprintf((char*)data_buff,"\nRbl%d%d %d %d %d",i+1,j+1 , (2*(j+1))*M+(i+1) , (2*(j+1))*M+(i+2), R_bl);
					hspice_gen<<data_buff;
				}
				else{
					sprintf((char*)data_buff,"\nRbl%d%d %d %d %d",i+1,j+1 , (2*(j+1))*M+(i+1) , 0, R_bl);
					hspice_gen<<data_buff;
				}
			
			}
		
		
		}
		sprintf((char*)data_buff,"\n* 33 *");
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n.OP");//compute the DC operating points;
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n.END");
		hspice_gen<<data_buff;
		
	
	
	
	
		hspice_gen.close();
	
	}
	else{
		std::cout<<"\nhspice_gen.is_open()\n";
	
	}
	
	







	return 0;
	
}





