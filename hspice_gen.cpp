































#include<iostream>//cout;
#include<fstream>//ofstream;

//#define M 3
//#define N 3

#define R_wl 5
#define R_bl 5
#define R_min 10
#define R_max 1000

#define V_in_min 10
#define V_in_max 40

#define fn_buff_sz 256
#define gen_ofn(dst,x,y) sprintf(dst,"./hspice/%dx%d_crossbar_gen",x,y)



int main(int argc,char** argv){
	unsigned int M,N;
	if(argc!=3){
		std::cout<<"\nusage: hspice_gen M N";
		
	}
	else{
		M=atoi(argv[1]); N=atoi(argv[2]);
	}
	
	unsigned char ofn[fn_buff_sz]; gen_ofn((char*)ofn,M,N);
	unsigned char data_buff[256];
	std::cout<<"out_fn= "<<ofn<<'\n';
	srand(time(NULL));//initialize random seed;
	
	unsigned int R[M][N];
	unsigned int V_in[M];

	std::ofstream hspice_gen((char*)ofn,std::ios::out);
	if(hspice_gen.is_open()){
		sprintf((char*)data_buff,"*%d by %d crossbar generated by shpice_gen.cpp",M,N);
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n*circuit");
		hspice_gen<<data_buff;
		for(unsigned int i=0;i<M;i++){//generate input voltage sources;
			
			V_in[i]=rand()%(V_in_max-V_in_min+1)+V_in_min;//inpit voltages;
			sprintf((char*)data_buff,"\nV%d %d 0 %d",i, i+1,V_in[i]);
			hspice_gen<<data_buff;
		}
		for(unsigned int i=0;i<M;i++){//gerating resistances 
			for(unsigned int j=0;j<N;j++){
				if(j!=0){//first collumn (bit line) (j==0) is voltage sources, so it should be generated separately;
					sprintf((char*)data_buff,"\nRwl%d%d %d %d %d",i+1,j+1 , (2*(j)-1)*M+(i+1) , (2*(j+1)-1)*M+(i+1) , R_wl);
					hspice_gen<<data_buff;
				}
				else{
					sprintf((char*)data_buff,"\nRwl%d%d %d %d %d",i+1,j+1 , i+1 , (2*(j+1)-1)*M+(i+1) , R_wl);
					hspice_gen<<data_buff;
				}
				R[i][j]=rand()%(R_max-R_min+1)+R_min;//memristor resistances;
				sprintf((char*)data_buff,"\nR%d%d %d %d %d",i+1,j+1 , (2*(j+1)-1)*M+(i+1) , (2*(j+1))*M+(i+1), R[i][j]);
				hspice_gen<<data_buff;
				if(i!=M-1){//for last word line its connection node is zero node, hence should be generated separately;
					sprintf((char*)data_buff,"\nRbl%d%d %d %d %d",i+1,j+1 , (2*(j+1))*M+(i+1) , (2*(j+1))*M+(i+2), R_bl);
					hspice_gen<<data_buff;
				}
				else{
					sprintf((char*)data_buff,"\nRbl%d%d %d %d %d",i+1,j+1 , (2*(j+1))*M+(i+1) , 0, R_bl);
					hspice_gen<<data_buff;
				}
			
			}
		
		
		}
		sprintf((char*)data_buff,"\n* 33 *");
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n.OP");//compute the DC operating points;
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n.OPTION post");//compute the DC operating points;
		hspice_gen<<data_buff;
		sprintf((char*)data_buff,"\n.END");
		hspice_gen<<data_buff;
		
	
	
	
	
		hspice_gen.close();
		std::cout.precision(10); 
		std::cout.setf(std::ios::fixed, std::ios::floatfield);//set output of floating point numbers to fixed format, to avoid "e" symbol in Mathematica;
		std::cout<<"\nCnds={";
		for(unsigned int i=0;i<M;i++){
			for(unsigned int j=0;j<N;j++){
				if(j==0){
					std::cout<<'{';
			
				}
				std::cout<<1./(double)(R[i][j]);
				if(j==N-1 && i!=M-1){
					std::cout<<"},";
				}
				else if(j!=N-1){
					std::cout<<',';
				}
			}
		
		}
		std::cout<<"}};";
		std::cout<<"\nGwl="<<1./R_wl<<"; Gbl="<<1./R_bl<<';';
		std::cout<<"\nVin={"<<V_in[0];
		for(unsigned int i=1;i<M;i++){
			std::cout<<','<<V_in[i];
		
		}
		std::cout<<"};\n";
		std::cout<<"precision="<<std::cout.precision();
		std::cout.precision(10);
		std::cout<<"\nnew precision="<<std::cout.precision();
		std::cout.setf(std::ios::fixed, std::ios::floatfield);
		std::cout<<"\nG_00="<<1./R[0][0];
	
	}
	else{
		std::cout<<"\nhspice_gen.is_open()\n";
	
	}
	
	







	return 0;
	
}





